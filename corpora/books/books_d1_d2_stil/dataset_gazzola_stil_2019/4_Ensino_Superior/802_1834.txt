 As duas primeiras fases são paralelas, sendo a segunda a fase de maior computação. A terceira e última fase deve ser feita de forma sequencial, mas sua computação é bem menor. As três fases serão agora vistas em detalhes. Precisamos definir partições sobre as quais serão criadas as R-trees separadamente. Essas partições precisam ter o mesmo tamanho, ou um tamanho muito próximo. Devem também possuir uma proximidade entre os pontos que as compõe, ao mesmo tempo em que esses pontos devem estar o mais distante possível dos pontos nas outras partições. Essa exigência acontece porque se tivermos duas R-trees de partições diferentes tratando de pontos próximos, os MBRs dos nós que contêm esses pontos em uma partição terão muita sobreposição com os nós de outra partição, e como já vimos anteriormente isso torna a R-tree ineficiente. A forma utilizada para definir essas partições faz uso de uma estrutura conhecida como curva de preenchimento de espaço (space filling curve). Essas curvas consistem em caminhamentos que induzem uma ordem em espaços multidimensionais com dois objetivos básicos:
Essas propriedades dessas curvas permitem que sejam utilizadas para definir mais facilmente as distâncias entre os pontos que compõem a base. No caso específico desse trabalho é utilizada a curva Z (z-curve), mas outras curvas poderiam ter sido escolhidas. Uma das vantadens da curva Z é sua facilidade para gerar a ordem segundo seu caminhamento. Basta concatenar as coordenadas do ponto que se deseja avaliar e ordenar os dígitos segundo a sua ordem nas coordenadas originais, de forma que os dígitos de mais alta ordem fiquem juntos. Por exemplo, se um ponto tem duas coordenadas 011 e 101, as coordenadas desse ponto na curva de ordem Z serão 011011. Uma vez que temos uma forma de definir uma ordem para todos os pontos da base, bastaria ordenar esses pontos e trabalhar sobre as partições segundo essa ordem. No entanto como trata-se de uma base muito grande esse processamento seria custoso demais.