 Isso aliado ao fato de que uma busca consiste em uma série de operações simples e que a R-tree é uma árvore balanceada significa que não há um gargalo de processamento das buscas devido ao desenho da R-tree. No entanto, o processo de criação de uma R-tree é custoso, pois embora muitas inserções necessitem apenas uma busca seguida de uma inserção em um nó folha, as etapas de checagem da melhor subárvore, no caso em que há mais de um nó-filho para inserir determinado objeto, e principalmente a divisão de um nó que excedeu o número máximo de filhos, são operações caras e que envolvem alterações significativas na estrutura da árvore, que impossibilitariam uma paralelização ingênua. Essa dificuldade de paralelização esbarra em uma exigência de se trabalhar com esse tipo de estrutura em um ambiente de big-data. E como vivemos em um mundo que possui, e precisa trabalhar, com um número cada vez maior de dados, é preciso desenvolver uma abordagem capaz de lidar com uma R-tree nesse tipo de contexto. Ariel Carry et al. apresentam uma abordagem para construção da R-tree em um ambiente de big-data utilizando o modelo de programação conhecido como MapReduce. O modelo MapReduce procura abstrair as dificuldades de se trabalhar com uma estrutura de clusters, com dados distribuídos e processamento paralelo. Para conseguir essa abstração o modelo trabalha apenas com duas funções básicas de controle de fluxo. A função map, que é responsável por definir um processamento individual para cada partição dos dados, e uma função reduce, que é capaz de organizar os dados vindos da função map executada anteriormente, aglutinando os dados processados. Por essa descrição superficial do modelo já é possível perceber que a implementação da R-tree nesse ambiente não pode ser feita diretamente. Para resolver essa situação será preciso utilizar três passos. São esses passos:
A ideia por trás das três fases é permitir a construção de R-trees, separadamente, sobre diferentes partições dos pontos e consolidar essas R-trees em uma única R-tree.