 O pseudo-código abaixo apresenta o algoritmo seguindo o modelo Pregel. Entrada: Mensagens "msgs" recebidas no "superstep" anterior. Considerando que a implementação principal do modelo Pregel da Google possui código fechado, pode ser interessante avaliar uma alternativa ao modelo Pregel. Uma das alternativas é o sistema GraphChi da GraphLab. Esse sistema fornece uma "engine" para processamento de grafos, no contexto de dados massivos, em uma única máquina. O sistema apresenta um processamento baseado em disco (memória secundária) para computação eficiente de grafos de grande escala. Diferentemente do modelo Pregel, GraphChi é uma "engine" baseada em memória compartilhada. Em GraphChi, cada vértice e cada aresta armazena um dado. A comunicação entre os vértices durante o processamento paralelo é realizada com base nos dados armazenados pelos vértices e arestas. De maneira semelhante ao modelo Pregel, GraphChi também apresenta uma abordagem centrada nos vértices. A "engine" do GraphChi consiste basicamente em uma sequência de iterações, nas quais, para cada vértice é executado uma função de atualização ("update"). Antes de cada iteração a "engine" executa uma função chamada "before_iteration" e após cada iteração é executada a função "after_iteration". A seguir é apresentado uma implementação do algoritmo de detecção de ciclos em grafos por passagem de mensagens usando o sistema do GraphChi. Esta implementação fornece uma abstração semelhante ao modelo Pregel sobre a engine do GraphChi, incluindo a abstração de passagem de mensagens, o que é conveniente para o algoritmo de detecção de ciclos proposto. Toda aplicação do sistema GraphChi deve implementar a classe abstrata GraphChiProgram. A classe GraphChiProgram fornece os métodos públicos apresentados pelo código da classe CycleDetection a seguir. O código a seguir apresenta a implementação do método "update" que é equivalente à função COMPUTE do modelo Pregel. O método "update" é a implementação principal do algoritmo de detecção de ciclos por passagem de mensagens apresentado anteriormente pelo pseudo-código da função COMPUTE. Basicamente, a implementação consiste em percorrer todas as arestas de entrada, recolhendo todas as "mensagens" recebidas, para poder realizar o processamento nas listas de vértices recebidas.