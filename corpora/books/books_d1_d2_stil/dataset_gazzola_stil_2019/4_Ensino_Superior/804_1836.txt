 Dessa forma a saída dessa fase é tantas R-trees quantas forem as partições definidas inicialmente. O paralelismo dessa etapa está restringido pelo número de partições definidas a priori. Quanto maior o número de partições maior o número de reducers construindo r-trees paralelamente. No entanto um número muito grande de partições em relação ao número de pontos pode levar a uma degeneração das partições e uma consequente degeneração das r-trees criadas, que tenderão a ter maior sobreposição entre si. A última fase não é executada em uma ambiente map-reduce. Trata-se de um processamento sequencial, que processa as R-trees formadas na etapa anterior para produzir uma só R-tree. Como as partições tendem a ter o mesmo número de pontos, cada R-tree deve possuir o mesmo número de pontos, e provavelmente a mesma altura, embora possa haver uma pequena variação. Isso significa que para forma a nova R-tree basta tomar o MBR de cada raiz e inserir em um árvore inicialmente vazia. Essa abordagem significa que o custo dessa última fase é o custo de inserção de P objetos (P é o número de partições) em uma R-tree, o que é um custo muito menor do que a criação de uma R-tree com os pontos originais. Toda a solução apresentada pode ser resumida no seguinte esquema:
Se analisarmos a figura apresentada ao final da seção anterior, embora essa represente a solução apresentada, é difícil ver naturalmente três fases nesse esquema. Isso significa que esse abordagem é artificial ao problema. E de fato trata-se de uma abordagem que se deve muito mais ao modelo map-reduce do que ao problema em si. Mas podemos pensar em um modelo que represente melhor esse esquema, de fato, podemos mapear muitas dessas entidades desse esquema a filtros de processamento, conforme a seguinte figura, em que os filtros estão pintados:
Os filtros fazem parte do modelo, naturalmente, servindo uns de entradas aos outros e resultando na R-tree dos pontos de entrada. Embora do ponto de vista da modelagem esse esquema faça mais sentido, o resultado final e o esforço computacional serão o mesmo da abordagem map-reduce apresentada anteriormente. No entanto, a abordagem utilizando streams é mais flexível, pois os filtros não processam sequencialmente, mas podem ser pensados como um processamento contínuo. Essa mudança de paradigma significa duas vantagens. Primeiramente, seria mais fácil pensar essa solução para uma situação em que esses pontos são processados de forma contínua, como em uma aplicação que seja alimentada com novos dados constantemente. A segunda vantagem é que esses filtros poderiam ser retroalimentados, aumentando o auto-conhecimento do processamento e assim possibilitando uma maior eficiência. Podemos adicionar os seguintes canais de comunicação entre os filtros, apresentados com linhas tracejadas:
Essa comunicação permitiria, por exemplo, adicionar um comportamento que verificasse o tamanho das partições à medida em que os dados são lidos pelo filtro “particiona pontos”, e no caso em que a partição estiver muito desbalanceada o procedimento de definição da função de partição, que envolve três filtros, pode ser realizado novamente. Outro comportamento que poderia surgir com esse modelo seria o de analisar o comportamento dos filtros que calculam as r-trees de cada partição em comparação com o resto do processo que poderia definir se o número de partições escolhido é um bom compromisso em termos da quantidade de paralelismo.