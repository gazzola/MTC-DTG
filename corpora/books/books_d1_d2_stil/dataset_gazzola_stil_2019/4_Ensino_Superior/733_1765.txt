 Na figura a baixo está listado o resultado obtido dos experimentos com as duas configurações e os dois tipos de particionamentos (1) e (4). Observa-se que ao processar os dados utilizando o particionamento (4) (Particionamento Temporal) a utilização do cache aumenta consideravelmente em relação ao particionamento (1). Outro resultado evidente é que ao utilizar o LAC Parametrizado o uso do cache também aumenta em relação ao LAC Não Parametrizado quando os dados são processados pelo particionamento (4). Diante destes resultados pode-se concluir que:
Além de avaliar a utilização do cache, neste caso também é necessário avaliar o quão preciso é o LAC utilizando Confiança e Suporte. Veloso et al. 2006 mencionam que não há valores genéricos para Confiança e Suporte, sendo dependente do domínio do dados e da modelagem. Os resutados desta comparação para este trabalho podem ser visualizados na figura a baixo. Nota-se que tanto no LAC Parametrizado como no LAC Não Parametrizado a acurácia não é penalizada ao utilizar o Particionamento Temporal, desta forma esta estrategia nos oferece uma melhora de desempenho sem implicar em perda de qualidade dos resultados gerados pelo classificador. Além disso, como comentado acima os valores para Confiança e Suporte variam de aplicação para aplicação e resultam em performances diferentes, neste caso configurar Confiança e Suporte iguais a 0.0 resultou em melhor performance do que a outra configuração. Em este projeto, apresentamos tres estrategias para tornar o LAC um classificador distribuido utilizando o Hadoop e analisamos diferentes formas de particionar o teste para tentar melhorar otimizar o acesso a cache de regras. Como nossos experimentos demostram um fator de grande importância é a boa distribuição das instancias em vários grupos. Isto aliado a estrategias de agrupamento, por similaridade ou ordenação temporal, pode levar a um melhor desempenho. Desta forma teremos uma melhor distribuição de carga conjuntamente com um melhor aproveitamento da cache interna do LAC. O código utilizado encontra-se disponivel no github.