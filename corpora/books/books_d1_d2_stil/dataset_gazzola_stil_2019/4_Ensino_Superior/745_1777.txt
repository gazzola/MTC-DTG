 A fase "apply" vai receber os valores parciais já somados, então basta atualizar o valor de acordo com o dumping factor. Além disso, ainda na fase "apply", vamos armazenar o valor de error calculando a diferença entre o novo e o antigo valor de PageRank, que será utilizado para decidir quais vértices deverão ser atualizados. A fase "scatter" é utilizada para ativar vértices que deverão ter seus valores atualizados na próxima iteração do algoritmo. Portanto, caso o valor de erro do vértice seja menor do que o valor máximo de tolerância, nenhuma aresta será ativa. Caso o valor de erro seja maior, serão ativas as arestas de saída. Cada aresta (u, v) ativa na fase "scatter" vai assinalar o vértice v para execução na próxima iteração. Ou seja, um vértice só será convocado para execução na próxima iteração se pelo menos um de seus vizinhos de entrada ainda não tiver convergido, pois são justamente os vértices utilizados para o cálculo de seu PageRank. O armazenamento é feito através do protocolo NFS, de forma que o acesso à base de dados seja transparente é igual entre os vértices. A base de dados pode ser dividida em arquivos, sendo uma opção de balanceamento explícito, entretanto como o protoclo já NFS provê o acesso aos vértices, optamos por deixar o balanceamento a carga do framework. A comunicação será feita sempre entre vértices e de forma transparente, devido a utilização do paradigma de programação do GraphLab. É interessante observar que, como a versão do algoritmo PageRank implementada é a não normalizada, não é necessário o compartilhamento de valores globais entre os vértices, como o número totais de vértices, que seria necessário para a versão normalizada. Utilizamos um ambiente virtual com Ubuntu OpenStack com quatro servidores virtuais com Hadoop e GraphLab configurados para executar os programas distribuídos. Cada máquina virtual tem um processador de dois núcleos, 4GB de Ram e 10GB de HD, rodando Ubuntu 12.04.