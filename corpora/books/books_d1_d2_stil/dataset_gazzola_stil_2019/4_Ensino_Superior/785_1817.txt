 Pode-se notar que a lista rejeitada contém o ciclo detectado anteriormente, e é por esse motivo que o vértice 2 aparece no meio da lista rejeitada, pois o ciclo é um sub-caminho do caminho representado pela lista rejeitada no passo (e). Por fim, no passo (f) todos os vértices são desativados e não existem mais mensagens sendo enviadas pelo grafo, terminando a execução do algoritmo. No passo (d) do exemplo, todos os três vértices detectam o ciclo (2,3,4). Para assegurar que apenas um dos vértices reportem a detecção, pode-se detectar o ciclo apenas do vértice cujo identificador seja o menor (por algum critério de ordenação) dentre os demais vértices do ciclo, onde no exemplo seria o vértice 2. O número total de iterações do algoritmo paralelo será igual ao tamanho do maior caminho de vértices distintos do grafo mais algumas poucas iterações iniciais ou finais. Portanto o número de iterações do algoritmo paralelo será Θ(|V|), sendo que o maior caminho distinto possível de um grafo seria contendo todos os vértices do grafo. Como mencionado anteriormente, o algoritmo proposto é baseado no modelo Pregel da Google. Nesse modelo de programação paralela, os programas de usuário são expressos como sequências de iterações, chamadas de "supersteps", nas quais cada vértice recebe mensagens enviadas por outros vértices na iteração anterior, envia mensagens para outros vértices, e modifica seu próprio estado e o estado das arestas de saída. O modelo Pregel é projetado para implementações em clusters de computadores que sejam eficientes, escaláveis e tolerante a falhas, de maneira que detalhes referentes à distribuição são escondidos pela abstração da API. O usuário desse modelo implementa um método chamado COMPUTE, que será executado por todos os vértices ativos em cada "superstep". O vértice se desativa votando para parar ("halt") e o algoritmo como um todo termina quando todos os vértices estão simultaneamente desativados e não existem mais mensagens sendo enviadas. Após carregar a estrutura do grafo, cada nó computacional do "cluster" de computadores fica responsável por um conjunto de vértices do grafo, e responsável também por executar o método COMPUTE a cada "supersteps" para os vértices sob sua responsabilidade.