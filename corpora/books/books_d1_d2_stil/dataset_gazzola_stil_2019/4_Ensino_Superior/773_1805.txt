 A estratégia supracidata foi implementada em C++ usando o framework MapReduce++, descrito nas próximas seção. As quatro caixas abaixo apresentam o código das funções de mapeamento e redução nas duas chamadas do MapReduce. O código é apresentado apenas a título de curiosidade, o intuito é mostrar como tais funções são implementadas nesse framework. O leitor pode pular esses códigos sem prejuízo de intrepretação e entendimento da abodagem adotata para implementar a estratégia proposta. Cada partição da base de dados é armazenada em um arquivo de transações. Trata-se de um arquivo de caracteres (textual), porém nada impede o uso de arquivos binários de bloco ou mesmo gerenciadores de banco de dados. A implementação feita nesse trabalho baseia-se no framework MaPI, que integra o projeto MapReduce++ (conforme discute-se na próxima seção). Esse framework é uma camada de abstração sobre MPI, ou Message Passing Interface. Portanto, a comunicação é feita por trocas de mensagens. = Execução =
A estratégia aqui apresentada foi implementada usando MapReduce++. MapReduce++ é um projeto open-source cujo objetivo é disponibilizar diferentes implementações da abstração MapReduce na linguagem de programação C++. Esse projeto define uma interface padrão para desenvolvimento de bibliotecas MapReduce, que serve como base para suas implementações. Atualmente, MapReduce++ contém duas implementações paralelas do modelo MapReduce:
Há também uma terceira versão, chamada SeqMR, que tem como objetivo auxiliar o usuário durante a etapa de desenvolvimento. Trata-se de uma versão sequencial para desenvolvimento. Portanto, caso o usuário não possua o ambiente de execução, este pode desenvolver a aplicação MapReduce usando SeqMR que não requer nenhum recurso além do gcc/g++. Finalizada a etapa de desenvovimento, o usuário deve então fazer pequenas adaptações no código para explorar o paralelismo intrínseco às tarefas de mapeamento e redução. São alterações como mudar a herança das classes de SeqMR para MapMP, no caso de memória compartilhada, ou para MaPI no caso de memória distribuída. Nesse último caso, faz-se necessária também a criação de serializadores e a inicialização dos servidores de mapeamento e redução.